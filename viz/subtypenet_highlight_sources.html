
<!DOCTYPE html>
<html>
  <head>
    <title>Force-Directed Layout</title>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src='fisheye.js' charset='utf-8'></script>
    <script src='d3.slider.js' charset='utf-8'></script>
    <link type="text/css" rel="stylesheet" href="force.css"/>
  </head>
  <body>
    <div id="nodeslider"></div>
    <div id="edgeslider"></div>
    <div id="chart"></div>
    <script type="text/javascript">

var width = 1200,
    height = 900;

var color = d3.scale.category10();

var force = d3.layout.force()
    .charge(-200)
    .linkDistance(200)
    .size([width, height]);

var radius = d3.scale.linear()
              .domain([0, 1])
              .range([5, 80])

var radiusMouseover = d3.scale.linear()
                        .domain([0, 1])
                        .range([10, 200])

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

d3.json("subtypenet.json", function(error, graph) {
  console.log(graph)
  force.nodes(graph.nodes)
      .links(graph.links)
      .start();

  var link = svg.selectAll(".link")
      .data(graph.links)
    .enter().append("line")
      .attr("class", "link")
      .style("stroke-width", 0.5)
      .style("stroke", function(d) { return color(d.segment)})
      .attr("d", linkArc);

  link.append("title")
      .text(function(d) { return "segment " + d.segment })

  var node = svg.selectAll(".node")
      .data(graph.nodes)
    .enter().append("circle")
      .attr("class", "node")
      .attr("r", function(d) { return radius(d.in_centrality)})
      .style("fill", "green")
      .style("opacity", 0.5)
      .call(force.drag)
      .on("mouseover", highlight(0.1))
      .on("mouseout", dehighlight())

  var text = svg.selectAll(".text")
      .data(graph.nodes)
    .enter().append("text")
      .attr("class", "text")
      .attr("x", function(d) { return d.x + 1.0 * radius(d.in_centrality) })
      .attr("y", function(d) { return d.y + 0.5 *  radius(d.in_centrality) })
      .text(function(d) { return d.id })  

  /** Function that draws the links as arc **/
  function linkArc(d) {
    var dx = d.target.x - d.source.x,
        dy = d.target.y - d.source.y,
        dr = Math.sqrt(dx * dx + dy * dy);

    return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
  }

  force.on("tick", function() {
    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; })
        .attr("d", linkArc);

    node.attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; })

    text.attr("x", function(d) { return d.x + 1.0 * radius(d.in_centrality) })
        .attr("y", function(d) { return d.y + 0.5 *  radius(d.in_centrality) })
  });

var linkedByIndex = {};
    graph.links.forEach(function(d) {
      linkedByIndex[d.source.index + "," + d.target.index] = 1;
  });


  function isConnected(a, b) {
    return linkedByIndex[b.index + "," + a.index] || a.index == b.index //|| linkedByIndex[b.index + "," + a.index];
  }


  function highlight(opacity) {
    /**  Set opacity of non-connected stuff to the parameter "opacity" **/
    return function(d) {
      var connected = []

      node.each(function(o) {
        if (isConnected(d, o)) {
          connected.push(o)
        }
      })

    /** Transition node to opacity 1.0, stroke **/
    node.transition()
          .duration(500)
          .style("opacity", function(o) {
            thisOpacity = opacity;
            connected.forEach( function(e) {
              if (isConnected(e, o)) {
                thisOpacity = 1;
              }
            })
          return thisOpacity
          })
          .ease("elastic")

    text.transition()
        .duration(500)
        .style("opacity", function(o) {
          thisOpacity = opacity;
          connected.forEach( function(e) {
            if (isConnected(e, o)) {
              thisOpacity = 1;
            }
          })
          return thisOpacity
        })
        .ease("elastic")


    /** 
    OBSERVATION:
    ------------
    If you use o.source == e, and pair it with [a.index + "," + b.index] above, then you get 
    the sinks going out of a moused-over node.

    If you use o.target == e, and pair it with [b.index + "," + a.index] above, then you get
    the sources going into a moused-over node.
     **/
    link.transition()
          .duration(500)
          .style("stroke-opacity", function(o) {
            thisOpacity = opacity;
            connected.forEach(function(e) {
              if (o.target == e) {
                thisOpacity = 1
              }
            })
            return thisOpacity
          })
          .style("stroke", function(o) {
            thisColor = "black";
            connected.forEach(function(e) {
              if (o.target == e) {
                thisColor = color(o.segment);
              }
            })
            return thisColor
          })
          .style("stroke-width", function(o){
            thisThickness = 0.5;
            connected.forEach(function(e) {
              if (o.target == e) {
                thisThickness = 2
              }
            })
            return thisThickness
          })
          .ease("elastic")

    d3.select(this)
        .transition()
        .duration(500)
        .attr("r", function(d) { return radius(d.in_centrality) * 2})
        .style("opacity", 1.0)
        .style("stroke", 2.0)
        .style("stroke-fill", "black")
        .ease("elastic")

    }
  }

  function dehighlight() {
    return function(d) {
      node.transition()
        .duration(500)
        .style("opacity", 0.5)
        .attr("r", function(d) { return radius(d.in_centrality) })
        .style("stroke", "none")
        // .style("stroke-fill", "white")
        .ease("elastic")
        
      link.transition()
        .duration(500)
        .style("stroke-opacity", 0.5)
        .style("stroke", function(d) { return color(d.segment) })
        .style("stroke-width", 0.5)
        .ease("elastic")

      text.transition()
          .duration(500)
          .style("opacity", 1)
          .ease("elastic")

    }
  }

});


    </script>
  </body>
</html>
